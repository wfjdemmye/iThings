// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.24.3
// source: proto/sys.proto

package sys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	User_UserCreate_FullMethodName     = "/sys.User/userCreate"
	User_UserIndex_FullMethodName      = "/sys.User/userIndex"
	User_UserUpdate_FullMethodName     = "/sys.User/userUpdate"
	User_UserRead_FullMethodName       = "/sys.User/userRead"
	User_UserDelete_FullMethodName     = "/sys.User/userDelete"
	User_UserLogin_FullMethodName      = "/sys.User/userLogin"
	User_UserCheckToken_FullMethodName = "/sys.User/userCheckToken"
)

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	UserCreate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserCreateResp, error)
	UserIndex(ctx context.Context, in *UserIndexReq, opts ...grpc.CallOption) (*UserIndexResp, error)
	UserUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error)
	UserRead(ctx context.Context, in *UserReadReq, opts ...grpc.CallOption) (*UserInfo, error)
	UserDelete(ctx context.Context, in *UserDeleteReq, opts ...grpc.CallOption) (*Response, error)
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
	UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) UserCreate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserCreateResp, error) {
	out := new(UserCreateResp)
	err := c.cc.Invoke(ctx, User_UserCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserIndex(ctx context.Context, in *UserIndexReq, opts ...grpc.CallOption) (*UserIndexResp, error) {
	out := new(UserIndexResp)
	err := c.cc.Invoke(ctx, User_UserIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, User_UserUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserRead(ctx context.Context, in *UserReadReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, User_UserRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserDelete(ctx context.Context, in *UserDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, User_UserDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, User_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error) {
	out := new(UserCheckTokenResp)
	err := c.cc.Invoke(ctx, User_UserCheckToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	UserCreate(context.Context, *UserInfo) (*UserCreateResp, error)
	UserIndex(context.Context, *UserIndexReq) (*UserIndexResp, error)
	UserUpdate(context.Context, *UserInfo) (*Response, error)
	UserRead(context.Context, *UserReadReq) (*UserInfo, error)
	UserDelete(context.Context, *UserDeleteReq) (*Response, error)
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) UserCreate(context.Context, *UserInfo) (*UserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreate not implemented")
}
func (UnimplementedUserServer) UserIndex(context.Context, *UserIndexReq) (*UserIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIndex not implemented")
}
func (UnimplementedUserServer) UserUpdate(context.Context, *UserInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdate not implemented")
}
func (UnimplementedUserServer) UserRead(context.Context, *UserReadReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRead not implemented")
}
func (UnimplementedUserServer) UserDelete(context.Context, *UserDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDelete not implemented")
}
func (UnimplementedUserServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserServer) UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCheckToken not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_UserCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserCreate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserIndex(ctx, req.(*UserIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserUpdate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserRead(ctx, req.(*UserReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserDelete(ctx, req.(*UserDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_UserCheckToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserCheckToken(ctx, req.(*UserCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "userCreate",
			Handler:    _User_UserCreate_Handler,
		},
		{
			MethodName: "userIndex",
			Handler:    _User_UserIndex_Handler,
		},
		{
			MethodName: "userUpdate",
			Handler:    _User_UserUpdate_Handler,
		},
		{
			MethodName: "userRead",
			Handler:    _User_UserRead_Handler,
		},
		{
			MethodName: "userDelete",
			Handler:    _User_UserDelete_Handler,
		},
		{
			MethodName: "userLogin",
			Handler:    _User_UserLogin_Handler,
		},
		{
			MethodName: "userCheckToken",
			Handler:    _User_UserCheckToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Role_RoleCreate_FullMethodName         = "/sys.Role/roleCreate"
	Role_RoleIndex_FullMethodName          = "/sys.Role/roleIndex"
	Role_RoleUpdate_FullMethodName         = "/sys.Role/roleUpdate"
	Role_RoleDelete_FullMethodName         = "/sys.Role/roleDelete"
	Role_RoleMenuUpdate_FullMethodName     = "/sys.Role/roleMenuUpdate"
	Role_RoleApiAuth_FullMethodName        = "/sys.Role/roleApiAuth"
	Role_RoleApiMultiUpdate_FullMethodName = "/sys.Role/roleApiMultiUpdate"
	Role_RoleApiIndex_FullMethodName       = "/sys.Role/roleApiIndex"
)

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleClient interface {
	RoleCreate(ctx context.Context, in *RoleCreateReq, opts ...grpc.CallOption) (*Response, error)
	RoleIndex(ctx context.Context, in *RoleIndexReq, opts ...grpc.CallOption) (*RoleIndexResp, error)
	RoleUpdate(ctx context.Context, in *RoleUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleDelete(ctx context.Context, in *RoleDeleteReq, opts ...grpc.CallOption) (*Response, error)
	RoleMenuUpdate(ctx context.Context, in *RoleMenuUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) RoleCreate(ctx context.Context, in *RoleCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Role_RoleCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleIndex(ctx context.Context, in *RoleIndexReq, opts ...grpc.CallOption) (*RoleIndexResp, error) {
	out := new(RoleIndexResp)
	err := c.cc.Invoke(ctx, Role_RoleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleUpdate(ctx context.Context, in *RoleUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Role_RoleUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleDelete(ctx context.Context, in *RoleDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Role_RoleDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleMenuUpdate(ctx context.Context, in *RoleMenuUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Role_RoleMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Role_RoleApiAuth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Role_RoleApiMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error) {
	out := new(RoleApiIndexResp)
	err := c.cc.Invoke(ctx, Role_RoleApiIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility
type RoleServer interface {
	RoleCreate(context.Context, *RoleCreateReq) (*Response, error)
	RoleIndex(context.Context, *RoleIndexReq) (*RoleIndexResp, error)
	RoleUpdate(context.Context, *RoleUpdateReq) (*Response, error)
	RoleDelete(context.Context, *RoleDeleteReq) (*Response, error)
	RoleMenuUpdate(context.Context, *RoleMenuUpdateReq) (*Response, error)
	RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error)
	RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error)
	RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServer struct {
}

func (UnimplementedRoleServer) RoleCreate(context.Context, *RoleCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleCreate not implemented")
}
func (UnimplementedRoleServer) RoleIndex(context.Context, *RoleIndexReq) (*RoleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleIndex not implemented")
}
func (UnimplementedRoleServer) RoleUpdate(context.Context, *RoleUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleUpdate not implemented")
}
func (UnimplementedRoleServer) RoleDelete(context.Context, *RoleDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleDelete not implemented")
}
func (UnimplementedRoleServer) RoleMenuUpdate(context.Context, *RoleMenuUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuUpdate not implemented")
}
func (UnimplementedRoleServer) RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiAuth not implemented")
}
func (UnimplementedRoleServer) RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiMultiUpdate not implemented")
}
func (UnimplementedRoleServer) RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiIndex not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_RoleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleCreate(ctx, req.(*RoleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleIndex(ctx, req.(*RoleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleUpdate(ctx, req.(*RoleUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleDelete(ctx, req.(*RoleDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleMenuUpdate(ctx, req.(*RoleMenuUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleApiAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleApiAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleApiAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleApiAuth(ctx, req.(*RoleApiAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleApiMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleApiMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleApiMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleApiMultiUpdate(ctx, req.(*RoleApiMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleApiIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleApiIndex(ctx, req.(*RoleApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "roleCreate",
			Handler:    _Role_RoleCreate_Handler,
		},
		{
			MethodName: "roleIndex",
			Handler:    _Role_RoleIndex_Handler,
		},
		{
			MethodName: "roleUpdate",
			Handler:    _Role_RoleUpdate_Handler,
		},
		{
			MethodName: "roleDelete",
			Handler:    _Role_RoleDelete_Handler,
		},
		{
			MethodName: "roleMenuUpdate",
			Handler:    _Role_RoleMenuUpdate_Handler,
		},
		{
			MethodName: "roleApiAuth",
			Handler:    _Role_RoleApiAuth_Handler,
		},
		{
			MethodName: "roleApiMultiUpdate",
			Handler:    _Role_RoleApiMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiIndex",
			Handler:    _Role_RoleApiIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Menu_MenuCreate_FullMethodName = "/sys.Menu/menuCreate"
	Menu_MenuIndex_FullMethodName  = "/sys.Menu/menuIndex"
	Menu_MenuUpdate_FullMethodName = "/sys.Menu/menuUpdate"
	Menu_MenuDelete_FullMethodName = "/sys.Menu/menuDelete"
)

// MenuClient is the client API for Menu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuClient interface {
	MenuCreate(ctx context.Context, in *MenuCreateReq, opts ...grpc.CallOption) (*Response, error)
	MenuIndex(ctx context.Context, in *MenuIndexReq, opts ...grpc.CallOption) (*MenuIndexResp, error)
	MenuUpdate(ctx context.Context, in *MenuUpdateReq, opts ...grpc.CallOption) (*Response, error)
	MenuDelete(ctx context.Context, in *MenuDeleteReq, opts ...grpc.CallOption) (*Response, error)
}

type menuClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuClient(cc grpc.ClientConnInterface) MenuClient {
	return &menuClient{cc}
}

func (c *menuClient) MenuCreate(ctx context.Context, in *MenuCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Menu_MenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) MenuIndex(ctx context.Context, in *MenuIndexReq, opts ...grpc.CallOption) (*MenuIndexResp, error) {
	out := new(MenuIndexResp)
	err := c.cc.Invoke(ctx, Menu_MenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) MenuUpdate(ctx context.Context, in *MenuUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Menu_MenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) MenuDelete(ctx context.Context, in *MenuDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Menu_MenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServer is the server API for Menu service.
// All implementations must embed UnimplementedMenuServer
// for forward compatibility
type MenuServer interface {
	MenuCreate(context.Context, *MenuCreateReq) (*Response, error)
	MenuIndex(context.Context, *MenuIndexReq) (*MenuIndexResp, error)
	MenuUpdate(context.Context, *MenuUpdateReq) (*Response, error)
	MenuDelete(context.Context, *MenuDeleteReq) (*Response, error)
	mustEmbedUnimplementedMenuServer()
}

// UnimplementedMenuServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServer struct {
}

func (UnimplementedMenuServer) MenuCreate(context.Context, *MenuCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuCreate not implemented")
}
func (UnimplementedMenuServer) MenuIndex(context.Context, *MenuIndexReq) (*MenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuIndex not implemented")
}
func (UnimplementedMenuServer) MenuUpdate(context.Context, *MenuUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuUpdate not implemented")
}
func (UnimplementedMenuServer) MenuDelete(context.Context, *MenuDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuDelete not implemented")
}
func (UnimplementedMenuServer) mustEmbedUnimplementedMenuServer() {}

// UnsafeMenuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServer will
// result in compilation errors.
type UnsafeMenuServer interface {
	mustEmbedUnimplementedMenuServer()
}

func RegisterMenuServer(s grpc.ServiceRegistrar, srv MenuServer) {
	s.RegisterService(&Menu_ServiceDesc, srv)
}

func _Menu_MenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menu_MenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuCreate(ctx, req.(*MenuCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_MenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menu_MenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuIndex(ctx, req.(*MenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_MenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menu_MenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuUpdate(ctx, req.(*MenuUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_MenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Menu_MenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuDelete(ctx, req.(*MenuDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Menu_ServiceDesc is the grpc.ServiceDesc for Menu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Menu",
	HandlerType: (*MenuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "menuCreate",
			Handler:    _Menu_MenuCreate_Handler,
		},
		{
			MethodName: "menuIndex",
			Handler:    _Menu_MenuIndex_Handler,
		},
		{
			MethodName: "menuUpdate",
			Handler:    _Menu_MenuUpdate_Handler,
		},
		{
			MethodName: "menuDelete",
			Handler:    _Menu_MenuDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Common_Config_FullMethodName = "/sys.Common/config"
)

// CommonClient is the client API for Common service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommonClient interface {
	Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error)
}

type commonClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonClient(cc grpc.ClientConnInterface) CommonClient {
	return &commonClient{cc}
}

func (c *commonClient) Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error) {
	out := new(ConfigResp)
	err := c.cc.Invoke(ctx, Common_Config_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonServer is the server API for Common service.
// All implementations must embed UnimplementedCommonServer
// for forward compatibility
type CommonServer interface {
	Config(context.Context, *Response) (*ConfigResp, error)
	mustEmbedUnimplementedCommonServer()
}

// UnimplementedCommonServer must be embedded to have forward compatible implementations.
type UnimplementedCommonServer struct {
}

func (UnimplementedCommonServer) Config(context.Context, *Response) (*ConfigResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedCommonServer) mustEmbedUnimplementedCommonServer() {}

// UnsafeCommonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonServer will
// result in compilation errors.
type UnsafeCommonServer interface {
	mustEmbedUnimplementedCommonServer()
}

func RegisterCommonServer(s grpc.ServiceRegistrar, srv CommonServer) {
	s.RegisterService(&Common_ServiceDesc, srv)
}

func _Common_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Common_Config_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).Config(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

// Common_ServiceDesc is the grpc.ServiceDesc for Common service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Common_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Common",
	HandlerType: (*CommonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "config",
			Handler:    _Common_Config_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Log_LoginLogIndex_FullMethodName  = "/sys.Log/loginLogIndex"
	Log_OperLogIndex_FullMethodName   = "/sys.Log/operLogIndex"
	Log_LoginLogCreate_FullMethodName = "/sys.Log/loginLogCreate"
	Log_OperLogCreate_FullMethodName  = "/sys.Log/operLogCreate"
)

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error)
	OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error)
	LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error)
	OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error) {
	out := new(LoginLogIndexResp)
	err := c.cc.Invoke(ctx, Log_LoginLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error) {
	out := new(OperLogIndexResp)
	err := c.cc.Invoke(ctx, Log_OperLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_LoginLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_OperLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error)
	OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error)
	LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error)
	OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error)
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogIndex not implemented")
}
func (UnimplementedLogServer) OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogIndex not implemented")
}
func (UnimplementedLogServer) LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogCreate not implemented")
}
func (UnimplementedLogServer) OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogCreate not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_LoginLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogIndex(ctx, req.(*LoginLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogIndex(ctx, req.(*OperLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_LoginLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogCreate(ctx, req.(*LoginLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogCreate(ctx, req.(*OperLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "loginLogIndex",
			Handler:    _Log_LoginLogIndex_Handler,
		},
		{
			MethodName: "operLogIndex",
			Handler:    _Log_OperLogIndex_Handler,
		},
		{
			MethodName: "loginLogCreate",
			Handler:    _Log_LoginLogCreate_Handler,
		},
		{
			MethodName: "operLogCreate",
			Handler:    _Log_OperLogCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Api_ApiCreate_FullMethodName = "/sys.Api/apiCreate"
	Api_ApiIndex_FullMethodName  = "/sys.Api/apiIndex"
	Api_ApiUpdate_FullMethodName = "/sys.Api/apiUpdate"
	Api_ApiDelete_FullMethodName = "/sys.Api/apiDelete"
)

// ApiClient is the client API for Api service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiClient interface {
	ApiCreate(ctx context.Context, in *ApiCreateReq, opts ...grpc.CallOption) (*Response, error)
	ApiIndex(ctx context.Context, in *ApiIndexReq, opts ...grpc.CallOption) (*ApiIndexResp, error)
	ApiUpdate(ctx context.Context, in *ApiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	ApiDelete(ctx context.Context, in *ApiDeleteReq, opts ...grpc.CallOption) (*Response, error)
}

type apiClient struct {
	cc grpc.ClientConnInterface
}

func NewApiClient(cc grpc.ClientConnInterface) ApiClient {
	return &apiClient{cc}
}

func (c *apiClient) ApiCreate(ctx context.Context, in *ApiCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Api_ApiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) ApiIndex(ctx context.Context, in *ApiIndexReq, opts ...grpc.CallOption) (*ApiIndexResp, error) {
	out := new(ApiIndexResp)
	err := c.cc.Invoke(ctx, Api_ApiIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) ApiUpdate(ctx context.Context, in *ApiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Api_ApiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) ApiDelete(ctx context.Context, in *ApiDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Api_ApiDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServer is the server API for Api service.
// All implementations must embed UnimplementedApiServer
// for forward compatibility
type ApiServer interface {
	ApiCreate(context.Context, *ApiCreateReq) (*Response, error)
	ApiIndex(context.Context, *ApiIndexReq) (*ApiIndexResp, error)
	ApiUpdate(context.Context, *ApiUpdateReq) (*Response, error)
	ApiDelete(context.Context, *ApiDeleteReq) (*Response, error)
	mustEmbedUnimplementedApiServer()
}

// UnimplementedApiServer must be embedded to have forward compatible implementations.
type UnimplementedApiServer struct {
}

func (UnimplementedApiServer) ApiCreate(context.Context, *ApiCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiCreate not implemented")
}
func (UnimplementedApiServer) ApiIndex(context.Context, *ApiIndexReq) (*ApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiIndex not implemented")
}
func (UnimplementedApiServer) ApiUpdate(context.Context, *ApiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiUpdate not implemented")
}
func (UnimplementedApiServer) ApiDelete(context.Context, *ApiDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiDelete not implemented")
}
func (UnimplementedApiServer) mustEmbedUnimplementedApiServer() {}

// UnsafeApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServer will
// result in compilation errors.
type UnsafeApiServer interface {
	mustEmbedUnimplementedApiServer()
}

func RegisterApiServer(s grpc.ServiceRegistrar, srv ApiServer) {
	s.RegisterService(&Api_ServiceDesc, srv)
}

func _Api_ApiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Api_ApiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiCreate(ctx, req.(*ApiCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_ApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Api_ApiIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiIndex(ctx, req.(*ApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_ApiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Api_ApiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiUpdate(ctx, req.(*ApiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_ApiDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Api_ApiDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiDelete(ctx, req.(*ApiDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Api_ServiceDesc is the grpc.ServiceDesc for Api service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Api_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Api",
	HandlerType: (*ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apiCreate",
			Handler:    _Api_ApiCreate_Handler,
		},
		{
			MethodName: "apiIndex",
			Handler:    _Api_ApiIndex_Handler,
		},
		{
			MethodName: "apiUpdate",
			Handler:    _Api_ApiUpdate_Handler,
		},
		{
			MethodName: "apiDelete",
			Handler:    _Api_ApiDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}
